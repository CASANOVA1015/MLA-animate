<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centering Operator Visualizations</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: #f5f5f5;
            margin: 0;
        }
        
        .container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 1000px;
            width: 100%;
        }
        
        h2 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .tab-button {
            padding: 10px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            color: #666;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }
        
        .tab-button:hover {
            color: #333;
        }
        
        .tab-button.active {
            color: #2196F3;
            border-bottom-color: #2196F3;
            font-weight: bold;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .canvas-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        canvas {
            border: 1px solid #ddd;
            background: white;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }
        
        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .info {
            background: #f0f8ff;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #2196F3;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin: 15px 0;
            font-size: 14px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 3px;
        }
        
        .math {
            font-family: 'Courier New', monospace;
            background: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
            justify-content: center;
        }
        
        .slider {
            width: 200px;
        }
        
        .stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
        }
        
        .stat-card {
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 5px;
            text-align: center;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }
        
        .eigenspace-explanation {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .explanation-card {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        .explanation-card h4 {
            color: #333;
            margin-top: 0;
            margin-bottom: 10px;
        }
        
        .explanation-card p {
            color: #666;
            line-height: 1.6;
            margin: 5px 0;
        }
        
        .vector-label {
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 3px;
            display: inline-block;
        }
        
        .kernel-label {
            background: #ffebee;
            color: #c62828;
        }
        
        .image-label {
            background: #e3f2fd;
            color: #1565c0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Centering Operator Œ≥ = I - (1/N)¬∑11·µÄ Visualizations</h2>
        
        <div class="tabs">
            <button class="tab-button active" onclick="showTab('matrix')">Matrix Transformation</button>
            <button class="tab-button" onclick="showTab('dataset')">Dataset Centering</button>
            <button class="tab-button" onclick="showTab('3d')">3D Projection</button>
            <button class="tab-button" onclick="showTab('eigen')">Eigenspace Analysis</button>
        </div>
        
        <!-- Matrix Animation Tab -->
        <div id="matrix" class="tab-content active">
            <div class="info">
                <strong>Matrix Transformation:</strong> Watch how the centering operator Œ≥ transforms vectors by removing their mean component.
            </div>
            <div class="canvas-container">
                <canvas id="matrixCanvas" width="700" height="500"></canvas>
            </div>
            <div class="controls">
                <button onclick="animateMatrix()">Animate Transformation</button>
                <button onclick="showMatrixSteps()">Step by Step</button>
                <button onclick="resetMatrix()">Reset</button>
            </div>
            <div class="math">
                Œ≥¬∑x = I¬∑x - (1/N)¬∑11·µÄ¬∑x = x - xÃÑ¬∑1
            </div>
        </div>
        
        <!-- Dataset Centering Tab -->
        <div id="dataset" class="tab-content">
            <div class="info">
                <strong>Dataset Centering:</strong> See how an entire dataset shifts to have zero mean.
            </div>
            <div class="canvas-container">
                <canvas id="datasetCanvas" width="700" height="500"></canvas>
            </div>
            <div class="controls">
                <button onclick="generateDataset()">Generate New Data</button>
                <button onclick="animateCentering()">Animate Centering</button>
                <button onclick="showBeforeAfter()">Before/After</button>
            </div>
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-label">Original Mean</div>
                    <div class="stat-value" id="origMean">(0, 0)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Centered Mean</div>
                    <div class="stat-value" id="centMean">(0, 0)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Data Points</div>
                    <div class="stat-value" id="numPoints">0</div>
                </div>
            </div>
        </div>
        
        <!-- 3D Projection Tab -->
        <div id="3d" class="tab-content">
            <div class="info">
                <strong>3D Centering:</strong> Projection onto the plane orthogonal to 1=(1,1,1). The plane satisfies x+y+z=0.
            </div>
            <div class="canvas-container">
                <canvas id="threeDCanvas" width="700" height="500"></canvas>
            </div>
            <div class="controls">
                <button onclick="animate3D()">Animate Projection</button>
                <button onclick="add3DPoint()">Add Random Point</button>
                <button onclick="toggleRotation()">Toggle Rotation</button>
                <button onclick="reset3D()">Reset View</button>
            </div>
            <div class="slider-container">
                <label>View Angle:</label>
                <input type="range" class="slider" id="angleX" min="-180" max="180" value="30">
                <input type="range" class="slider" id="angleY" min="-180" max="180" value="45">
            </div>
        </div>
        
        <!-- Eigenspace Tab -->
        <div id="eigen" class="tab-content">
            <div class="info">
                <strong>Eigenspace Decomposition:</strong> Understanding Œ≥ through its eigenvalues and eigenvectors.
            </div>
            
            <div class="eigenspace-explanation">
                <div class="explanation-card">
                    <h4>üî¥ Eigenvalue Œª = 0 (Kernel)</h4>
                    <p>‚Ä¢ <span class="vector-label kernel-label">Eigenvector: 1 = (1,1)</span></p>
                    <p>‚Ä¢ This is the direction that gets "collapsed" to zero</p>
                    <p>‚Ä¢ Œ≥¬∑1 = 0¬∑1 = 0</p>
                    <p>‚Ä¢ Represents the "mean direction" that we remove</p>
                </div>
                <div class="explanation-card">
                    <h4>üîµ Eigenvalue Œª = 1 (Image)</h4>
                    <p>‚Ä¢ <span class="vector-label image-label">All vectors in 1‚ä•</span></p>
                    <p>‚Ä¢ These directions are preserved</p>
                    <p>‚Ä¢ Œ≥¬∑v = 1¬∑v = v for all v ‚ä• 1</p>
                    <p>‚Ä¢ This is the subspace where centered data lives</p>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="eigenCanvas" width="700" height="500"></canvas>
            </div>
            
            <div class="controls">
                <button onclick="animateEigenDecomposition()">Animate Decomposition</button>
                <button onclick="showEigenBasis()">Show Eigen Basis</button>
                <button onclick="testRandomVector()">Test Random Vector</button>
                <button onclick="showMatrixForm()">Show Matrix Form</button>
            </div>
            
            <div class="math" id="eigenMath">
                Click "Animate Decomposition" to see how any vector is decomposed into eigenspaces
            </div>
        </div>
    </div>

    <script>
        // Tab switching
        function showTab(tabName) {
            const tabs = document.querySelectorAll('.tab-content');
            const buttons = document.querySelectorAll('.tab-button');
            
            tabs.forEach(tab => tab.classList.remove('active'));
            buttons.forEach(btn => btn.classList.remove('active'));
            
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            
            // Initialize the specific visualization
            initializeVisualization(tabName);
        }
        
        // Initialize visualizations
        function initializeVisualization(tabName) {
            switch(tabName) {
                case 'matrix':
                    initMatrixVisualization();
                    break;
                case 'dataset':
                    initDatasetVisualization();
                    break;
                case '3d':
                    init3DVisualization();
                    break;
                case 'eigen':
                    initEigenVisualization();
                    break;
            }
        }
        
        // Matrix Animation Implementation
        let matrixCtx, matrixAnimationId;
        let matrixStep = 0;
        
        function initMatrixVisualization() {
            const canvas = document.getElementById('matrixCanvas');
            matrixCtx = canvas.getContext('2d');
            drawMatrixGrid();
        }
        
        function drawMatrixGrid() {
            const ctx = matrixCtx;
            const width = 700;
            const height = 500;
            const centerX = width / 2;
            const centerY = height / 2;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            
            for (let i = -3; i <= 3; i++) {
                ctx.beginPath();
                ctx.moveTo(centerX + i * 60, 50);
                ctx.lineTo(centerX + i * 60, height - 50);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(50, centerY + i * 60);
                ctx.lineTo(width - 50, centerY + i * 60);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, centerY);
            ctx.lineTo(width - 50, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 50);
            ctx.lineTo(centerX, height - 50);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText('x‚ÇÅ', width - 40, centerY - 10);
            ctx.fillText('x‚ÇÇ', centerX + 10, 60);
            
            // Draw initial vectors
            drawMatrixVector(2, 1.5, '#2196F3', 'v‚ÇÅ');
            drawMatrixVector(-1.5, 2, '#4CAF50', 'v‚ÇÇ');
            drawMatrixVector(1, -1.5, '#FF9800', 'v‚ÇÉ');
        }
        
        function drawMatrixVector(x, y, color, label, alpha = 1) {
            const ctx = matrixCtx;
            const centerX = 350;
            const centerY = 250;
            const scale = 60;
            
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + x * scale, centerY - y * scale);
            ctx.stroke();
            
            // Arrowhead
            const angle = Math.atan2(-y, x);
            const headLength = 8;
            
            ctx.beginPath();
            ctx.moveTo(centerX + x * scale, centerY - y * scale);
            ctx.lineTo(
                centerX + x * scale - headLength * Math.cos(angle - Math.PI/6),
                centerY - y * scale + headLength * Math.sin(angle - Math.PI/6)
            );
            ctx.lineTo(
                centerX + x * scale - headLength * Math.cos(angle + Math.PI/6),
                centerY - y * scale + headLength * Math.sin(angle + Math.PI/6)
            );
            ctx.closePath();
            ctx.fill();
            
            if (label) {
                ctx.font = 'bold 14px Arial';
                ctx.fillText(label, centerX + x * scale + 10, centerY - y * scale);
            }
            
            ctx.globalAlpha = 1;
        }
        
        function animateMatrix() {
            let t = 0;
            const duration = 3000;
            const startTime = Date.now();
            
            const vectors = [
                {x: 2, y: 1.5, color: '#2196F3', label: 'v‚ÇÅ'},
                {x: -1.5, y: 2, color: '#4CAF50', label: 'v‚ÇÇ'},
                {x: 1, y: -1.5, color: '#FF9800', label: 'v‚ÇÉ'}
            ];
            
            function animate() {
                const elapsed = Date.now() - startTime;
                t = Math.min(elapsed / duration, 1);
                
                drawMatrixGrid();
                
                vectors.forEach(v => {
                    // Draw original vector (fading)
                    drawMatrixVector(v.x, v.y, v.color, '', 1 - t * 0.7);
                    
                    // Calculate and draw transformed vector
                    const mean = (v.x + v.y) / 2;
                    const projX = v.x - mean * t;
                    const projY = v.y - mean * t;
                    drawMatrixVector(projX, projY, v.color, v.label);
                    
                    // Draw mean component
                    if (t > 0.3 && t < 0.9) {
                        const ctx = matrixCtx;
                        ctx.strokeStyle = '#F44336';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([3, 3]);
                        ctx.globalAlpha = 0.5;
                        
                        const centerX = 350;
                        const centerY = 250;
                        const scale = 60;
                        
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.lineTo(centerX + mean * t * scale, centerY - mean * t * scale);
                        ctx.stroke();
                        
                        ctx.setLineDash([]);
                        ctx.globalAlpha = 1;
                    }
                });
                
                if (t < 1) {
                    matrixAnimationId = requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        function showMatrixSteps() {
            const vectors = [
                {x: 2, y: 1.5, color: '#2196F3', label: 'v‚ÇÅ'},
                {x: -1.5, y: 2, color: '#4CAF50', label: 'v‚ÇÇ'},
                {x: 1, y: -1.5, color: '#FF9800', label: 'v‚ÇÉ'}
            ];
            
            const steps = [0, 0.33, 0.66, 1];
            const t = steps[matrixStep % 4];
            
            drawMatrixGrid();
            
            vectors.forEach(v => {
                if (t > 0) {
                    drawMatrixVector(v.x, v.y, v.color, '', 0.3);
                }
                
                const mean = (v.x + v.y) / 2;
                const projX = v.x - mean * t;
                const projY = v.y - mean * t;
                drawMatrixVector(projX, projY, v.color, v.label);
            });
            
            matrixStep++;
        }
        
        function resetMatrix() {
            if (matrixAnimationId) {
                cancelAnimationFrame(matrixAnimationId);
            }
            matrixStep = 0;
            drawMatrixGrid();
        }
        
        // Dataset Centering Implementation
        let datasetCtx, dataPoints = [], centeredPoints = [];
        
        function initDatasetVisualization() {
            const canvas = document.getElementById('datasetCanvas');
            datasetCtx = canvas.getContext('2d');
            generateDataset();
        }
        
        function generateDataset() {
            dataPoints = [];
            for (let i = 0; i < 50; i++) {
                dataPoints.push({
                    x: (Math.random() - 0.5) * 4 + 1.5,
                    y: (Math.random() - 0.5) * 4 + 1
                });
            }
            
            const meanX = dataPoints.reduce((sum, p) => sum + p.x, 0) / dataPoints.length;
            const meanY = dataPoints.reduce((sum, p) => sum + p.y, 0) / dataPoints.length;
            
            centeredPoints = dataPoints.map(p => ({
                x: p.x - meanX,
                y: p.y - meanY
            }));
            
            document.getElementById('origMean').textContent = `(${meanX.toFixed(2)}, ${meanY.toFixed(2)})`;
            document.getElementById('centMean').textContent = '(0.00, 0.00)';
            document.getElementById('numPoints').textContent = dataPoints.length;
            
            drawDataset(dataPoints, '#2196F3');
        }
        
        function drawDataset(points, color, showMean = true) {
            const ctx = datasetCtx;
            const width = 700;
            const height = 500;
            const centerX = width / 2;
            const centerY = height / 2;
            const scale = 60;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            for (let i = -4; i <= 4; i++) {
                ctx.beginPath();
                ctx.moveTo(centerX + i * scale, 50);
                ctx.lineTo(centerX + i * scale, height - 50);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(50, centerY + i * scale);
                ctx.lineTo(width - 50, centerY + i * scale);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, centerY);
            ctx.lineTo(width - 50, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 50);
            ctx.lineTo(centerX, height - 50);
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = color;
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(centerX + p.x * scale, centerY - p.y * scale, 3, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Draw mean
            if (showMean && points === dataPoints) {
                const meanX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
                const meanY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
                
                ctx.fillStyle = '#F44336';
                ctx.strokeStyle = '#F44336';
                ctx.lineWidth = 2;
                
                // Cross for mean
                ctx.beginPath();
                ctx.moveTo(centerX + meanX * scale - 8, centerY - meanY * scale);
                ctx.lineTo(centerX + meanX * scale + 8, centerY - meanY * scale);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(centerX + meanX * scale, centerY - meanY * scale - 8);
                ctx.lineTo(centerX + meanX * scale, centerY - meanY * scale + 8);
                ctx.stroke();
                
                ctx.font = 'bold 14px Arial';
                ctx.fillText('Mean', centerX + meanX * scale + 10, centerY - meanY * scale);
            }
        }
        
        function animateCentering() {
            let t = 0;
            const duration = 2000;
            const startTime = Date.now();
            const meanX = dataPoints.reduce((sum, p) => sum + p.x, 0) / dataPoints.length;
            const meanY = dataPoints.reduce((sum, p) => sum + p.y, 0) / dataPoints.length;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                t = Math.min(elapsed / duration, 1);
                
                const currentPoints = dataPoints.map(p => ({
                    x: p.x - meanX * t,
                    y: p.y - meanY * t
                }));
                
                drawDataset(currentPoints, '#2196F3', t < 0.9);
                
                if (t < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        function showBeforeAfter() {
            const ctx = datasetCtx;
            const width = 700;
            const height = 500;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw dividing line
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(width / 2, 50);
            ctx.lineTo(width / 2, height - 50);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Original', width / 4 - 30, 30);
            ctx.fillText('Centered', 3 * width / 4 - 30, 30);
            
            const scale = 40;
            const leftCenterX = width / 4;
            const rightCenterX = 3 * width / 4;
            const centerY = height / 2;
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(50, centerY);
            ctx.lineTo(width / 2 - 20, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(leftCenterX, 80);
            ctx.lineTo(leftCenterX, height - 80);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(width / 2 + 20, centerY);
            ctx.lineTo(width - 50, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(rightCenterX, 80);
            ctx.lineTo(rightCenterX, height - 80);
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = '#2196F3';
            dataPoints.forEach(p => {
                ctx.beginPath();
                ctx.arc(leftCenterX + p.x * scale, centerY - p.y * scale, 2, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            ctx.fillStyle = '#9C27B0';
            centeredPoints.forEach(p => {
                ctx.beginPath();
                ctx.arc(rightCenterX + p.x * scale, centerY - p.y * scale, 2, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Draw means
            const meanX = dataPoints.reduce((sum, p) => sum + p.x, 0) / dataPoints.length;
            const meanY = dataPoints.reduce((sum, p) => sum + p.y, 0) / dataPoints.length;
            
            ctx.strokeStyle = '#F44336';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(leftCenterX + meanX * scale - 6, centerY - meanY * scale);
            ctx.lineTo(leftCenterX + meanX * scale + 6, centerY - meanY * scale);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(leftCenterX + meanX * scale, centerY - meanY * scale - 6);
            ctx.lineTo(leftCenterX + meanX * scale, centerY - meanY * scale + 6);
            ctx.stroke();
            
            ctx.strokeStyle = '#4CAF50';
            ctx.beginPath();
            ctx.moveTo(rightCenterX - 6, centerY);
            ctx.lineTo(rightCenterX + 6, centerY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(rightCenterX, centerY - 6);
            ctx.lineTo(rightCenterX, centerY + 6);
            ctx.stroke();
        }
        
        // 3D Visualization Implementation
        let threeDCtx, rotation = {x: 0.5, y: 0.8}, autoRotate = false;
        let points3D = [];
        
        function init3DVisualization() {
            const canvas = document.getElementById('threeDCanvas');
            threeDCtx = canvas.getContext('2d');
            
            points3D = [
                {x: 2, y: 1, z: 1.5},
                {x: -1, y: 2, z: 0.5},
                {x: 1, y: -1, z: 2},
                {x: 0.5, y: 1.5, z: -0.5}
            ];
            
            document.getElementById('angleX').addEventListener('input', (e) => {
                rotation.x = e.target.value * Math.PI / 180;
                draw3D();
            });
            
            document.getElementById('angleY').addEventListener('input', (e) => {
                rotation.y = e.target.value * Math.PI / 180;
                draw3D();
            });
            
            draw3D();
        }
        
        function project3Dto2D(x, y, z) {
            const scale = 80;
            const centerX = 350;
            const centerY = 250;
            
            // Apply rotation
            const cosX = Math.cos(rotation.x);
            const sinX = Math.sin(rotation.x);
            const cosY = Math.cos(rotation.y);
            const sinY = Math.sin(rotation.y);
            
            // Rotate around X axis
            const y1 = y * cosX - z * sinX;
            const z1 = y * sinX + z * cosX;
            
            // Rotate around Y axis
            const x2 = x * cosY + z1 * sinY;
            const z2 = -x * sinY + z1 * cosY;
            
            return {
                x: centerX + x2 * scale,
                y: centerY - y1 * scale,
                z: z2
            };
        }
        
        function draw3D() {
            const ctx = threeDCtx;
            const width = 700;
            const height = 500;
            
            ctx.clearRect(0, 0, width, height);
            
            // Sort elements by depth
            const elements = [];
            
            // Add axes
            elements.push({
                type: 'axis',
                color: '#F44336',
                points: [project3Dto2D(-3, 0, 0), project3Dto2D(3, 0, 0)],
                label: 'x',
                z: (project3Dto2D(-3, 0, 0).z + project3Dto2D(3, 0, 0).z) / 2
            });
            
            elements.push({
                type: 'axis',
                color: '#4CAF50',
                points: [project3Dto2D(0, -3, 0), project3Dto2D(0, 3, 0)],
                label: 'y',
                z: (project3Dto2D(0, -3, 0).z + project3Dto2D(0, 3, 0).z) / 2
            });
            
            elements.push({
                type: 'axis',
                color: '#2196F3',
                points: [project3Dto2D(0, 0, -3), project3Dto2D(0, 0, 3)],
                label: 'z',
                z: (project3Dto2D(0, 0, -3).z + project3Dto2D(0, 0, 3).z) / 2
            });
            
            // Add 1 vector
            const oneStart = project3Dto2D(0, 0, 0);
            const oneEnd = project3Dto2D(1, 1, 1);
            elements.push({
                type: 'vector',
                color: '#FF9800',
                start: oneStart,
                end: oneEnd,
                label: '1',
                z: (oneStart.z + oneEnd.z) / 2
            });
            
            // Add plane
            const planeCorners = [
                project3Dto2D(-2, -1, 3),
                project3Dto2D(3, -2, -1),
                project3Dto2D(1, 2, -3),
                project3Dto2D(-3, 1, 2)
            ];
            
            elements.push({
                type: 'plane',
                points: planeCorners,
                z: planeCorners.reduce((sum, p) => sum + p.z, 0) / 4
            });
            
            // Add points and projections
            points3D.forEach(p => {
                const point3D = project3Dto2D(p.x, p.y, p.z);
                const mean = (p.x + p.y + p.z) / 3;
                const proj3D = project3Dto2D(p.x - mean, p.y - mean, p.z - mean);
                
                elements.push({
                    type: 'line',
                    start: point3D,
                    end: proj3D,
                    z: (point3D.z + proj3D.z) / 2
                });
                
                elements.push({
                    type: 'point',
                    pos: point3D,
                    color: '#2196F3',
                    z: point3D.z
                });
                
                elements.push({
                    type: 'point',
                    pos: proj3D,
                    color: '#9C27B0',
                    z: proj3D.z
                });
            });
            
            // Sort by depth
            elements.sort((a, b) => a.z - b.z);
            
            // Draw elements
            elements.forEach(el => {
                if (el.type === 'axis') {
                    ctx.strokeStyle = el.color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();
                    ctx.moveTo(el.points[0].x, el.points[0].y);
                    ctx.lineTo(el.points[1].x, el.points[1].y);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    
                    ctx.fillStyle = el.color;
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText(el.label, el.points[1].x + 5, el.points[1].y);
                } else if (el.type === 'plane') {
                    ctx.fillStyle = 'rgba(156, 39, 176, 0.1)';
                    ctx.strokeStyle = 'rgba(156, 39, 176, 0.3)';
                    ctx.lineWidth = 1;
                    
                    ctx.beginPath();
                    ctx.moveTo(el.points[0].x, el.points[0].y);
                    el.points.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (el.type === 'vector') {
                    ctx.strokeStyle = el.color;
                    ctx.fillStyle = el.color;
                    ctx.lineWidth = 3;
                    
                    ctx.beginPath();
                    ctx.moveTo(el.start.x, el.start.y);
                    ctx.lineTo(el.end.x, el.end.y);
                    ctx.stroke();
                    
                    // Arrowhead
                    const angle = Math.atan2(el.end.y - el.start.y, el.end.x - el.start.x);
                    const headLength = 10;
                    
                    ctx.beginPath();
                    ctx.moveTo(el.end.x, el.end.y);
                    ctx.lineTo(
                        el.end.x - headLength * Math.cos(angle - Math.PI/6),
                        el.end.y - headLength * Math.sin(angle - Math.PI/6)
                    );
                    ctx.lineTo(
                        el.end.x - headLength * Math.cos(angle + Math.PI/6),
                        el.end.y - headLength * Math.sin(angle + Math.PI/6)
                    );
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText(el.label, el.end.x + 10, el.end.y);
                } else if (el.type === 'line') {
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(el.start.x, el.start.y);
                    ctx.lineTo(el.end.x, el.end.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                } else if (el.type === 'point') {
                    ctx.fillStyle = el.color;
                    ctx.beginPath();
                    ctx.arc(el.pos.x, el.pos.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            
            // Add legend
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.fillText('Blue: Original points', 20, height - 40);
            ctx.fillText('Purple: Centered points on x+y+z=0', 20, height - 20);
        }
        
        function animate3D() {
            let t = 0;
            const duration = 2000;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                t = Math.min(elapsed / duration, 1);
                
                const ctx = threeDCtx;
                const width = 700;
                const height = 500;
                
                ctx.clearRect(0, 0, width, height);
                
                // Draw axes
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 1;
                
                const xStart = project3Dto2D(-3, 0, 0);
                const xEnd = project3Dto2D(3, 0, 0);
                ctx.strokeStyle = '#F44336';
                ctx.beginPath();
                ctx.moveTo(xStart.x, xStart.y);
                ctx.lineTo(xEnd.x, xEnd.y);
                ctx.stroke();
                
                const yStart = project3Dto2D(0, -3, 0);
                const yEnd = project3Dto2D(0, 3, 0);
                ctx.strokeStyle = '#4CAF50';
                ctx.beginPath();
                ctx.moveTo(yStart.x, yStart.y);
                ctx.lineTo(yEnd.x, yEnd.y);
                ctx.stroke();
                
                const zStart = project3Dto2D(0, 0, -3);
                const zEnd = project3Dto2D(0, 0, 3);
                ctx.strokeStyle = '#2196F3';
                ctx.beginPath();
                ctx.moveTo(zStart.x, zStart.y);
                ctx.lineTo(zEnd.x, zEnd.y);
                ctx.stroke();
                
                // Draw plane
                ctx.fillStyle = 'rgba(156, 39, 176, 0.1)';
                ctx.strokeStyle = 'rgba(156, 39, 176, 0.3)';
                const planeCorners = [
                    project3Dto2D(-2, -1, 3),
                    project3Dto2D(3, -2, -1),
                    project3Dto2D(1, 2, -3),
                    project3Dto2D(-3, 1, 2)
                ];
                ctx.beginPath();
                ctx.moveTo(planeCorners[0].x, planeCorners[0].y);
                planeCorners.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Animate points
                points3D.forEach(p => {
                    const mean = (p.x + p.y + p.z) / 3;
                    const currentX = p.x - mean * t;
                    const currentY = p.y - mean * t;
                    const currentZ = p.z - mean * t;
                    
                    const point2D = project3Dto2D(currentX, currentY, currentZ);
                    
                    ctx.fillStyle = t < 1 ? '#2196F3' : '#9C27B0';
                    ctx.beginPath();
                    ctx.arc(point2D.x, point2D.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                if (t < 1) {
                    requestAnimationFrame(animate);
                } else {
                    draw3D();
                }
            }
            
            animate();
        }
        
        function add3DPoint() {
            points3D.push({
                x: (Math.random() - 0.5) * 4,
                y: (Math.random() - 0.5) * 4,
                z: (Math.random() - 0.5) * 4
            });
            draw3D();
        }
        
        function toggleRotation() {
            autoRotate = !autoRotate;
            if (autoRotate) {
                animateRotation();
            }
        }
        
        function animateRotation() {
            if (!autoRotate) return;
            
            rotation.y += 0.01;
            draw3D();
            requestAnimationFrame(animateRotation);
        }
        
        function reset3D() {
            autoRotate = false;
            points3D = [
                {x: 2, y: 1, z: 1.5},
                {x: -1, y: 2, z: 0.5},
                {x: 1, y: -1, z: 2},
                {x: 0.5, y: 1.5, z: -0.5}
            ];
            rotation = {x: 0.5, y: 0.8};
            document.getElementById('angleX').value = 30;
            document.getElementById('angleY').value = 45;
            draw3D();
        }
        
        // Eigenspace Implementation
        let eigenCtx, eigenAnimationId;
        
        function initEigenVisualization() {
            const canvas = document.getElementById('eigenCanvas');
            eigenCtx = canvas.getContext('2d');
            drawEigenspace();
        }
        
        function drawEigenspace() {
            const ctx = eigenCtx;
            const width = 700;
            const height = 500;
            const centerX = width / 2;
            const centerY = height / 2;
            const scale = 80;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            for (let i = -3; i <= 3; i++) {
                ctx.beginPath();
                ctx.moveTo(centerX + i * scale, 50);
                ctx.lineTo(centerX + i * scale, height - 50);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(50, centerY + i * scale);
                ctx.lineTo(width - 50, centerY + i * scale);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, centerY);
            ctx.lineTo(width - 50, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 50);
            ctx.lineTo(centerX, height - 50);
            ctx.stroke();
            
            // Draw eigenspace for Œª=0 (red line along 1)
            ctx.strokeStyle = '#F44336';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - 2.5*scale, centerY - 2.5*scale);
            ctx.lineTo(centerX + 2.5*scale, centerY + 2.5*scale);
            ctx.stroke();
            
            // Draw eigenspace for Œª=1 (blue dashed line, 1‚ä•)
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(centerX - 2.5*scale, centerY + 2.5*scale);
            ctx.lineTo(centerX + 2.5*scale, centerY - 2.5*scale);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Labels
            ctx.fillStyle = '#F44336';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('Œª=0 (kernel)', centerX + 2.6*scale, centerY + 2.6*scale);
            
            ctx.fillStyle = '#2196F3';
            ctx.fillText('Œª=1 (1‚ä•)', centerX + 2.6*scale, centerY - 2.4*scale);
            
            // Draw 1 vector
            ctx.strokeStyle = '#FF9800';
            ctx.fillStyle = '#FF9800';
            ctx.lineWidth = 2;
            
            const oneX = scale;
            const oneY = scale;
            
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + oneX, centerY - oneY);
            ctx.stroke();
            
            // Arrowhead
            const angle = Math.atan2(-oneY, oneX);
            const headLength = 10;
            
            ctx.beginPath();
            ctx.moveTo(centerX + oneX, centerY - oneY);
            ctx.lineTo(
                centerX + oneX - headLength * Math.cos(angle - Math.PI/6),
                centerY - oneY + headLength * Math.sin(angle - Math.PI/6)
            );
            ctx.lineTo(
                centerX + oneX - headLength * Math.cos(angle + Math.PI/6),
                centerY - oneY + headLength * Math.sin(angle + Math.PI/6)
            );
            ctx.closePath();
            ctx.fill();
            
            ctx.font = 'bold 16px Arial';
            ctx.fillText('1', centerX + oneX + 10, centerY - oneY);
        }
        
        function animateEigenDecomposition() {
            if (eigenAnimationId) {
                cancelAnimationFrame(eigenAnimationId);
            }
            
            let t = 0;
            const duration = 4000;
            const startTime = Date.now();
            
            // Test vector
            const testX = 2;
            const testY = 0.5;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                t = Math.min(elapsed / duration, 1);
                
                drawEigenspace();
                
                const ctx = eigenCtx;
                const centerX = 350;
                const centerY = 250;
                const scale = 80;
                
                // Phase 1: Show original vector (0-0.25)
                // Phase 2: Decompose into components (0.25-0.5)
                // Phase 3: Apply transformation (0.5-0.75)
                // Phase 4: Show result (0.75-1)
                
                if (t <= 0.25) {
                    // Show original vector
                    const alpha = t * 4;
                    ctx.globalAlpha = alpha;
                    drawEigenVector(testX, testY, '#666', 'v');
                    ctx.globalAlpha = 1;
                    
                    document.getElementById('eigenMath').innerHTML = 
                        `Original vector: v = (${testX}, ${testY})`;
                } else if (t <= 0.5) {
                    // Show decomposition
                    drawEigenVector(testX, testY, '#666', 'v', 0.3);
                    
                    const decompT = (t - 0.25) * 4;
                    
                    // Component along 1
                    const proj1 = (testX + testY) / 2;
                    ctx.globalAlpha = decompT;
                    ctx.strokeStyle = '#F44336';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(centerX + proj1 * scale, centerY - proj1 * scale);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Component in 1‚ä•
                    ctx.strokeStyle = '#2196F3';
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(centerX + (testX - proj1) * scale, centerY - (testY - proj1) * scale);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    
                    document.getElementById('eigenMath').innerHTML = 
                        `Decomposition: v = <span style="color:#F44336">${proj1.toFixed(2)}¬∑(1,1)</span> + ` +
                        `<span style="color:#2196F3">(${(testX-proj1).toFixed(2)}, ${(testY-proj1).toFixed(2)})</span>`;
                } else if (t <= 0.75) {
                    // Apply transformation
                    const transT = (t - 0.5) * 4;
                    const proj1 = (testX + testY) / 2;
                    
                    // Fade out the component along 1
                    ctx.globalAlpha = 1 - transT;
                    ctx.strokeStyle = '#F44336';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(centerX + proj1 * scale * (1 - transT), centerY - proj1 * scale * (1 - transT));
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.globalAlpha = 1;
                    
                    // Keep the 1‚ä• component
                    drawEigenVector(testX - proj1, testY - proj1, '#2196F3', 'Œ≥v');
                    
                    document.getElementById('eigenMath').innerHTML = 
                        `Applying Œ≥: <span style="color:#F44336">Œª=0 kills (1,1) component</span>, ` +
                        `<span style="color:#2196F3">Œª=1 preserves 1‚ä• component</span>`;
                } else {
                    // Show result
                    const proj1 = (testX + testY) / 2;
                    drawEigenVector(testX - proj1, testY - proj1, '#9C27B0', 'Œ≥v = v - proj‚ÇÅ(v)');
                    
                    document.getElementById('eigenMath').innerHTML = 
                        `Result: Œ≥v = (${(testX-proj1).toFixed(2)}, ${(testY-proj1).toFixed(2)}) ‚àà 1‚ä•`;
                }
                
                if (t < 1) {
                    eigenAnimationId = requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        function drawEigenVector(x, y, color, label, alpha = 1) {
            const ctx = eigenCtx;
            const centerX = 350;
            const centerY = 250;
            const scale = 80;
            
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + x * scale, centerY - y * scale);
            ctx.stroke();
            
            // Arrowhead
            const angle = Math.atan2(-y, x);
            const headLength = 8;
            
            ctx.beginPath();
            ctx.moveTo(centerX + x * scale, centerY - y * scale);
            ctx.lineTo(
                centerX + x * scale - headLength * Math.cos(angle - Math.PI/6),
                centerY - y * scale + headLength * Math.sin(angle - Math.PI/6)
            );
            ctx.lineTo(
                centerX + x * scale - headLength * Math.cos(angle + Math.PI/6),
                centerY - y * scale + headLength * Math.sin(angle + Math.PI/6)
            );
            ctx.closePath();
            ctx.fill();
            
            if (label) {
                ctx.font = 'bold 14px Arial';
                ctx.fillText(label, centerX + x * scale + 10, centerY - y * scale);
            }
            
            ctx.globalAlpha = 1;
        }
        
        function showEigenBasis() {
            drawEigenspace();
            
            const ctx = eigenCtx;
            const centerX = 350;
            const centerY = 250;
            const scale = 80;
            
            // Show basis vectors
            // For Œª=0
            drawEigenVector(1, 1, '#F44336', 'e‚ÇÅ=(1,1)/‚àö2', 0.8);
            
            // For Œª=1
            drawEigenVector(1, -1, '#2196F3', 'e‚ÇÇ=(1,-1)/‚àö2', 0.8);
            
            document.getElementById('eigenMath').innerHTML = 
                'Eigenbasis: {e‚ÇÅ=(1,1)/‚àö2, e‚ÇÇ=(1,-1)/‚àö2}<br>' +
                'Matrix form: Œ≥ = [e‚ÇÅ e‚ÇÇ] ¬∑ diag(0,1) ¬∑ [e‚ÇÅ e‚ÇÇ]·µÄ';
        }
        
        function testRandomVector() {
            const x = (Math.random() - 0.5) * 4;
            const y = (Math.random() - 0.5) * 4;
            
            drawEigenspace();
            
            const ctx = eigenCtx;
            const centerX = 350;
            const centerY = 250;
            const scale = 80;
            
            // Draw original
            drawEigenVector(x, y, '#666', 'v');
            
            // Draw projection
            const mean = (x + y) / 2;
            drawEigenVector(x - mean, y - mean, '#9C27B0', 'Œ≥v');
            
            // Draw connection
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(centerX + x * scale, centerY - y * scale);
            ctx.lineTo(centerX + (x - mean) * scale, centerY - (y - mean) * scale);
            ctx.stroke();
            ctx.setLineDash([]);
            
            document.getElementById('eigenMath').innerHTML = 
                `v = (${x.toFixed(2)}, ${y.toFixed(2)})<br>` +
                `mean = ${mean.toFixed(2)}<br>` +
                `Œ≥v = (${(x-mean).toFixed(2)}, ${(y-mean).toFixed(2)})`;
        }
        
        function showMatrixForm() {
            const ctx = eigenCtx;
            const width = 700;
            const height = 500;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw matrix representation
            ctx.fillStyle = '#333';
            ctx.font = '20px Arial';
            ctx.fillText('Matrix Form of Œ≥ in ‚Ñù¬≤', 250, 100);
            
            ctx.font = '18px Courier New';
            
            // Draw Œ≥ matrix
            ctx.fillText('Œ≥ = I - (1/2)¬∑11·µÄ =', 100, 200);
            
            // Draw identity matrix
            ctx.fillText('[1  0]', 300, 180);
            ctx.fillText('[0  1]', 300, 210);
            
            ctx.fillText('-', 380, 195);
            
            // Draw (1/2)¬∑11·µÄ
            ctx.fillText('1/2 ¬∑', 420, 195);
            ctx.fillText('[1  1]', 480, 180);
            ctx.fillText('[1  1]', 480, 210);
            
            ctx.fillText('=', 200, 280);
            
            // Result
            ctx.fillText('[1/2  -1/2]', 250, 265);
            ctx.fillText('[-1/2  1/2]', 250, 295);
            
            // Eigenvalue decomposition
            ctx.font = '16px Arial';
            ctx.fillText('Eigenvalue Decomposition:', 100, 380);
            
            ctx.font = '14px Courier New';
            ctx.fillText('Œ≥ = V Œõ V·µÄ where V = [1/‚àö2  1/‚àö2], Œõ = [0  0]', 100, 420);
            ctx.fillText('                    [1/‚àö2 -1/‚àö2]      [0  1]', 100, 445);
            
            document.getElementById('eigenMath').innerHTML = 
                'The centering matrix has rank N-1 (here: rank 1)';
        }
        
        // Initialize on load
        window.onload = () => {
            initMatrixVisualization();
        };
    </script>
</body>
</html>
