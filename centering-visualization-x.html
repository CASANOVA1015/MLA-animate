<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centering Operator - Multiple Visualizations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .tab-button {
            padding: 12px 24px;
            background: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .tab-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        
        .tab-button.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .tab-content {
            display: none;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .visualization-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        canvas {
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            background: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: scale(1);
        }
        
        .info-box {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 5px solid #667eea;
        }
        
        .formula {
            font-family: 'Courier New', monospace;
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
            font-size: 16px;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
        }
        
        .slider {
            width: 200px;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #ddd;
            border-radius: 5px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #667eea;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>Centering Operator γ = I - (1/N)·11ᵀ</h1>
        
        <div class="tabs">
            <button class="tab-button active" onclick="showTab('matrix')">Matrix Animation</button>
            <button class="tab-button" onclick="showTab('dataset')">Dataset Centering</button>
            <button class="tab-button" onclick="showTab('3d')">3D Projection</button>
            <button class="tab-button" onclick="showTab('eigen')">Eigenspace</button>
            <button class="tab-button" onclick="showTab('pca')">PCA Preprocessing</button>
        </div>
        
        <!-- Matrix Animation Tab -->
        <div id="matrix" class="tab-content active">
            <div class="visualization-container">
                <h2>Matrix Transformation Visualization</h2>
                <div class="info-box">
                    <strong>Watch how γ transforms vectors:</strong> 
                    The matrix γ = I - (1/N)·11ᵀ removes the mean component from any vector.
                </div>
                <canvas id="matrixCanvas" width="800" height="500"></canvas>
                <div class="controls">
                    <button class="btn" onclick="animateMatrix()">Animate Transformation</button>
                    <button class="btn" onclick="showMatrixSteps()">Show Step by Step</button>
                    <button class="btn" onclick="resetMatrix()">Reset</button>
                </div>
                <div class="formula">
                    γ·x = I·x - (1/N)·11ᵀ·x = x - x̄·1
                </div>
            </div>
        </div>
        
        <!-- Dataset Centering Tab -->
        <div id="dataset" class="tab-content">
            <div class="visualization-container">
                <h2>Dataset Centering Animation</h2>
                <div class="info-box">
                    <strong>Centering a cloud of points:</strong> 
                    See how an entire dataset shifts to have zero mean.
                </div>
                <canvas id="datasetCanvas" width="800" height="500"></canvas>
                <div class="controls">
                    <button class="btn" onclick="generateDataset()">Generate New Data</button>
                    <button class="btn" onclick="animateCentering()">Animate Centering</button>
                    <button class="btn" onclick="showBeforeAfter()">Before/After</button>
                </div>
                <div class="stats" id="dataStats">
                    <div class="stat-card">
                        <div class="stat-label">Original Mean</div>
                        <div class="stat-value" id="origMean">(0, 0)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Centered Mean</div>
                        <div class="stat-value" id="centMean">(0, 0)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Data Points</div>
                        <div class="stat-value" id="numPoints">0</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 3D Projection Tab -->
        <div id="3d" class="tab-content">
            <div class="visualization-container">
                <h2>3D Orthogonal Projection</h2>
                <div class="info-box">
                    <strong>Centering in ℝ³:</strong> 
                    Projection onto the plane orthogonal to 1=(1,1,1). Use mouse to rotate view.
                </div>
                <canvas id="threeDCanvas" width="800" height="500"></canvas>
                <div class="controls">
                    <button class="btn" onclick="animate3D()">Animate Projection</button>
                    <button class="btn" onclick="add3DPoint()">Add Random Point</button>
                    <button class="btn" onclick="reset3D()">Reset View</button>
                </div>
                <div class="slider-container">
                    <label>Rotation Speed:</label>
                    <input type="range" class="slider" id="rotSpeed" min="0" max="100" value="50">
                    <span id="rotSpeedValue">50</span>
                </div>
            </div>
        </div>
        
        <!-- Eigenspace Tab -->
        <div id="eigen" class="tab-content">
            <div class="visualization-container">
                <h2>Eigenspace Decomposition</h2>
                <div class="info-box">
                    <strong>Spectral properties of γ:</strong> 
                    γ has eigenvalue 0 for 1 and eigenvalue 1 for all vectors in 1⊥.
                </div>
                <canvas id="eigenCanvas" width="800" height="500"></canvas>
                <div class="controls">
                    <button class="btn" onclick="showEigenDecomposition()">Show Eigenvectors</button>
                    <button class="btn" onclick="animateEigenTransform()">Animate Transform</button>
                    <button class="btn" onclick="showSpectrum()">Show Spectrum</button>
                </div>
                <div class="formula">
                    γ·1 = 0·1 (eigenvalue λ₁ = 0)<br>
                    γ·v = 1·v for all v ⊥ 1 (eigenvalue λ₂ = 1)
                </div>
            </div>
        </div>
        
        <!-- PCA Preprocessing Tab -->
        <div id="pca" class="tab-content">
            <div class="visualization-container">
                <h2>PCA Preprocessing: Why Centering Matters</h2>
                <div class="info-box">
                    <strong>Principal Component Analysis:</strong> 
                    Centering is crucial for finding the correct principal components.
                </div>
                <canvas id="pcaCanvas" width="800" height="500"></canvas>
                <div class="controls">
                    <button class="btn" onclick="generatePCAData()">Generate Data</button>
                    <button class="btn" onclick="showPCAWithout()">PCA Without Centering</button>
                    <button class="btn" onclick="showPCAWith()">PCA With Centering</button>
                    <button class="btn" onclick="comparePCA()">Compare Both</button>
                </div>
                <div class="stats" id="pcaStats">
                    <div class="stat-card">
                        <div class="stat-label">Variance Explained (PC1)</div>
                        <div class="stat-value" id="pc1Var">0%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Variance Explained (PC2)</div>
                        <div class="stat-value" id="pc2Var">0%</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Tab switching
        function showTab(tabName) {
            const tabs = document.querySelectorAll('.tab-content');
            const buttons = document.querySelectorAll('.tab-button');
            
            tabs.forEach(tab => tab.classList.remove('active'));
            buttons.forEach(btn => btn.classList.remove('active'));
            
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            
            // Initialize the specific visualization
            initializeVisualization(tabName);
        }
        
        // Initialize visualizations
        function initializeVisualization(tabName) {
            switch(tabName) {
                case 'matrix':
                    initMatrixVisualization();
                    break;
                case 'dataset':
                    initDatasetVisualization();
                    break;
                case '3d':
                    init3DVisualization();
                    break;
                case 'eigen':
                    initEigenVisualization();
                    break;
                case 'pca':
                    initPCAVisualization();
                    break;
            }
        }
        
        // Matrix Animation Implementation
        let matrixCtx, matrixAnimationId;
        
        function initMatrixVisualization() {
            const canvas = document.getElementById('matrixCanvas');
            matrixCtx = canvas.getContext('2d');
            drawMatrixGrid();
        }
        
        function drawMatrixGrid() {
            const ctx = matrixCtx;
            const width = 800;
            const height = 500;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw coordinate system
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            
            // Grid
            for (let i = 0; i <= 10; i++) {
                ctx.beginPath();
                ctx.moveTo(50 + i * 70, 50);
                ctx.lineTo(50 + i * 70, 450);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(50, 50 + i * 40);
                ctx.lineTo(750, 50 + i * 40);
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(400, 50);
            ctx.lineTo(400, 450);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(50, 250);
            ctx.lineTo(750, 250);
            ctx.stroke();
            
            // Draw sample vectors
            drawVector(200, 150, '#2196F3', 'x₁');
            drawVector(300, 200, '#4CAF50', 'x₂');
            drawVector(250, 100, '#FF9800', 'x₃');
        }
        
        function drawVector(x, y, color, label) {
            const ctx = matrixCtx;
            const centerX = 400;
            const centerY = 250;
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 3;
            
            // Draw arrow
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + x, centerY - y);
            ctx.stroke();
            
            // Arrowhead
            const angle = Math.atan2(-y, x);
            const headLength = 10;
            
            ctx.beginPath();
            ctx.moveTo(centerX + x, centerY - y);
            ctx.lineTo(
                centerX + x - headLength * Math.cos(angle - Math.PI/6),
                centerY - y + headLength * Math.sin(angle - Math.PI/6)
            );
            ctx.lineTo(
                centerX + x - headLength * Math.cos(angle + Math.PI/6),
                centerY - y + headLength * Math.sin(angle + Math.PI/6)
            );
            ctx.closePath();
            ctx.fill();
            
            // Label
            ctx.font = 'bold 14px Arial';
            ctx.fillText(label, centerX + x + 10, centerY - y);
        }
        
        function animateMatrix() {
            let t = 0;
            const duration = 3000;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                t = Math.min(elapsed / duration, 1);
                
                drawMatrixGrid();
                
                // Animate transformation
                const vectors = [
                    {x: 200, y: 150, color: '#2196F3', label: 'x₁'},
                    {x: 300, y: 200, color: '#4CAF50', label: 'x₂'},
                    {x: 250, y: 100, color: '#FF9800', label: 'x₃'}
                ];
                
                vectors.forEach(v => {
                    const mean = (v.x + v.y) / 2 / Math.sqrt(2);
                    const projX = v.x - mean * t;
                    const projY = v.y - mean * t;
                    drawVector(projX, projY, v.color, v.label);
                });
                
                if (t < 1) {
                    matrixAnimationId = requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        function showMatrixSteps() {
            // Implementation for step-by-step visualization
            console.log('Showing matrix steps...');
        }
        
        function resetMatrix() {
            if (matrixAnimationId) {
                cancelAnimationFrame(matrixAnimationId);
            }
            drawMatrixGrid();
        }
        
        // Dataset Centering Implementation
        let datasetCtx, dataPoints = [], centeredPoints = [];
        
        function initDatasetVisualization() {
            const canvas = document.getElementById('datasetCanvas');
            datasetCtx = canvas.getContext('2d');
            generateDataset();
        }
        
        function generateDataset() {
            dataPoints = [];
            for (let i = 0; i < 50; i++) {
                dataPoints.push({
                    x: Math.random() * 4 - 1 + 2,
                    y: Math.random() * 4 - 1 + 1
                });
            }
            
            // Calculate mean
            const meanX = dataPoints.reduce((sum, p) => sum + p.x, 0) / dataPoints.length;
            const meanY = dataPoints.reduce((sum, p) => sum + p.y, 0) / dataPoints.length;
            
            // Calculate centered points
            centeredPoints = dataPoints.map(p => ({
                x: p.x - meanX,
                y: p.y - meanY
            }));
            
            // Update stats
            document.getElementById('origMean').textContent = `(${meanX.toFixed(2)}, ${meanY.toFixed(2)})`;
            document.getElementById('centMean').textContent = '(0.00, 0.00)';
            document.getElementById('numPoints').textContent = dataPoints.length;
            
            drawDataset(dataPoints, '#2196F3');
        }
        
        function drawDataset(points, color) {
            const ctx = datasetCtx;
            const width = 800;
            const height = 500;
            const centerX = width / 2;
            const centerY = height / 2;
            const scale = 60;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = color;
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(centerX + p.x * scale, centerY - p.y * scale, 3, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Draw mean point
            if (points === dataPoints) {
                const meanX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
                const meanY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
                
                ctx.fillStyle = '#F44336';
                ctx.beginPath();
                ctx.arc(centerX + meanX * scale, centerY - meanY * scale, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.fillText('Mean', centerX + meanX * scale + 10, centerY - meanY * scale);
            }
        }
        
        function animateCentering() {
            let t = 0;
            const duration = 2000;
            const startTime = Date.now();
            const meanX = dataPoints.reduce((sum, p) => sum + p.x, 0) / dataPoints.length;
            const meanY = dataPoints.reduce((sum, p) => sum + p.y, 0) / dataPoints.length;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                t = Math.min(elapsed / duration, 1);
                
                // Interpolate points
                const currentPoints = dataPoints.map(p => ({
                    x: p.x - meanX * t,
                    y: p.y - meanY * t
                }));
                
                drawDataset(currentPoints, '#2196F3');
                
                if (t < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        function showBeforeAfter() {
            // Split screen showing before and after
            const ctx = datasetCtx;
            const width = 800;
            const height = 500;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw dividing line
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(width / 2, 0);
            ctx.lineTo(width / 2, height);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Original', width / 4 - 30, 30);
            ctx.fillText('Centered', 3 * width / 4 - 30, 30);
            
            // Draw original on left
            const scale = 40;
            const leftCenterX = width / 4;
            const rightCenterX = 3 * width / 4;
            const centerY = height / 2;
            
            // Left axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(50, centerY);
            ctx.lineTo(width / 2 - 50, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(leftCenterX, 50);
            ctx.lineTo(leftCenterX, height - 50);
            ctx.stroke();
            
            // Right axes
            ctx.beginPath();
            ctx.moveTo(width / 2 + 50, centerY);
            ctx.lineTo(width - 50, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(rightCenterX, 50);
            ctx.lineTo(rightCenterX, height - 50);
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = '#2196F3';
            dataPoints.forEach(p => {
                ctx.beginPath();
                ctx.arc(leftCenterX + p.x * scale, centerY - p.y * scale, 3, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            ctx.fillStyle = '#9C27B0';
            centeredPoints.forEach(p => {
                ctx.beginPath();
                ctx.arc(rightCenterX + p.x * scale, centerY - p.y * scale, 3, 0, 2 * Math.PI);
                ctx.fill();
            });
        }
        
        // 3D Visualization Implementation
        let threeDCtx, rotation = {x: 0.5, y: 0.5, z: 0};
        let points3D = [];
        
        function init3DVisualization() {
            const canvas = document.getElementById('threeDCanvas');
            threeDCtx = canvas.getContext('2d');
            
            // Add some initial points
            points3D = [
                {x: 2, y: 1, z: 1.5},
                {x: -1, y: 2, z: 0.5},
                {x: 1, y: -1, z: 2}
            ];
            
            draw3D();
            
            // Setup rotation control
            document.getElementById('rotSpeed').addEventListener('input', (e) => {
                document.getElementById('rotSpeedValue').textContent = e.target.value;
            });
            
            // Auto-rotate
            animate3DRotation();
        }
        
        function project3Dto2D(x, y, z) {
            const scale = 100;
            const centerX = 400;
            const centerY = 250;
            
            // Apply rotation
            const cosX = Math.cos(rotation.x);
            const sinX = Math.sin(rotation.x);
            const cosY = Math.cos(rotation.y);
            const sinY = Math.sin(rotation.y);
            
            // Rotate around X axis
            const y1 = y * cosX - z * sinX;
            const z1 = y * sinX + z * cosX;
            
            // Rotate around Y axis
            const x2 = x * cosY + z1 * sinY;
            const z2 = -x * sinY + z1 * cosY;
            
            // Project to 2D (simple orthographic projection)
            return {
                x: centerX + x2 * scale,
                y: centerY - y1 * scale
            };
        }
        
        function draw3D() {
            const ctx = threeDCtx;
            const width = 800;
            const height = 500;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw axes
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            
            // X axis (red)
            const xStart = project3Dto2D(-3, 0, 0);
            const xEnd = project3Dto2D(3, 0, 0);
            ctx.strokeStyle = '#F44336';
            ctx.beginPath();
            ctx.moveTo(xStart.x, xStart.y);
            ctx.lineTo(xEnd.x, xEnd.y);
            ctx.stroke();
            
            // Y axis (green)
            const yStart = project3Dto2D(0, -3, 0);
            const yEnd = project3Dto2D(0, 3, 0);
            ctx.strokeStyle = '#4CAF50';
            ctx.beginPath();
            ctx.moveTo(yStart.x, yStart.y);
            ctx.lineTo(yEnd.x, yEnd.y);
            ctx.stroke();
            
            // Z axis (blue)
            const zStart = project3Dto2D(0, 0, -3);
            const zEnd = project3Dto2D(0, 0, 3);
            ctx.strokeStyle = '#2196F3';
            ctx.beginPath();
            ctx.moveTo(zStart.x, zStart.y);
            ctx.lineTo(zEnd.x, zEnd.y);
            ctx.stroke();
            
            // Draw 1 vector
            const oneVector = project3Dto2D(1, 1, 1);
            const origin = project3Dto2D(0, 0, 0);
            ctx.strokeStyle = '#FF9800';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(oneVector.x, oneVector.y);
            ctx.stroke();
            
            // Draw plane orthogonal to 1
            ctx.strokeStyle = 'rgba(156, 39, 176, 0.3)';
            ctx.fillStyle = 'rgba(156, 39, 176, 0.1)';
            ctx.lineWidth = 1;
            
            // Draw grid on the plane x + y + z = 0
            const planePoints = [
                project3Dto2D(-2, -1, 3),
                project3Dto2D(3, -2, -1),
                project3Dto2D(1, 2, -3),
                project3Dto2D(-3, 1, 2)
            ];
            
            ctx.beginPath();
            ctx.moveTo(planePoints[0].x, planePoints[0].y);
            planePoints.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw points and their projections
            points3D.forEach(p => {
                const point2D = project3Dto2D(p.x, p.y, p.z);
                
                // Original point
                ctx.fillStyle = '#2196F3';
                ctx.beginPath();
                ctx.arc(point2D.x, point2D.y, 5, 0, 2 * Math.PI);
                ctx.fill();
                
                // Calculate projection
                const mean = (p.x + p.y + p.z) / 3;
                const projX = p.x - mean;
                const projY = p.y - mean;
                const projZ = p.z - mean;
                const proj2D = project3Dto2D(projX, projY, projZ);
                
                // Projected point
                ctx.fillStyle = '#9C27B0';
                ctx.beginPath();
                ctx.arc(proj2D.x, proj2D.y, 5, 0, 2 * Math.PI);
                ctx.fill();
                
                // Connection line
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(point2D.x, point2D.y);
                ctx.lineTo(proj2D.x, proj2D.y);
                ctx.stroke();
                ctx.setLineDash([]);
            });
        }
        
        function animate3DRotation() {
            const speed = document.getElementById('rotSpeed').value / 1000;
            rotation.y += speed;
            
            draw3D();
            requestAnimationFrame(animate3DRotation);
        }
        
        function animate3D() {
            // Animate projection of points
            let t = 0;
            const duration = 2000;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                t = Math.min(elapsed / duration, 1);
                
                // Temporarily modify points for animation
                const tempPoints = points3D.map(p => {
                    const mean = (p.x + p.y + p.z) / 3;
                    return {
                        x: p.x - mean * t,
                        y: p.y - mean * t,
                        z: p.z - mean * t
                    };
                });
                
                // Swap temporarily
                const backup = points3D;
                points3D = tempPoints;
                draw3D();
                points3D = backup;
                
                if (t < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        function add3DPoint() {
            points3D.push({
                x: Math.random() * 4 - 2,
                y: Math.random() * 4 - 2,
                z: Math.random() * 4 - 2
            });
            draw3D();
        }
        
        function reset3D() {
            points3D = [
                {x: 2, y: 1, z: 1.5},
                {x: -1, y: 2, z: 0.5},
                {x: 1, y: -1, z: 2}
            ];
            rotation = {x: 0.5, y: 0.5, z: 0};
            draw3D();
        }
        
        // Eigenspace Implementation
        let eigenCtx;
        
        function initEigenVisualization() {
            const canvas = document.getElementById('eigenCanvas');
            eigenCtx = canvas.getContext('2d');
            drawEigenspace();
        }
        
        function drawEigenspace() {
            const ctx = eigenCtx;
            const width = 800;
            const height = 500;
            const centerX = width / 2;
            const centerY = height / 2;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
            
            // Draw eigenspaces
            const scale = 80;
            
            // Eigenspace for λ=0 (span of 1)
            ctx.strokeStyle = '#F44336';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - 200, centerY - 200);
            ctx.lineTo(centerX + 200, centerY + 200);
            ctx.stroke();
            
            ctx.fillStyle = '#F44336';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('λ=0 (kernel)', centerX + 210, centerY + 210);
            
            // Eigenspace for λ=1 (1⊥)
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(centerX - 200, centerY + 200);
            ctx.lineTo(centerX + 200, centerY - 200);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#2196F3';
            ctx.fillText('λ=1 (1⊥)', centerX + 210, centerY - 190);
            
            // Draw sample eigenvectors
            drawEigenvector(1, 1, 0, '#F44336');
            drawEigenvector(1, -1, 1, '#2196F3');
            drawEigenvector(-1, 1, 1, '#2196F3');
        }
        
        function drawEigenvector(x, y, eigenvalue, color) {
            const ctx = eigenCtx;
            const centerX = 400;
            const centerY = 250;
            const scale = 100;
            
            // Normalize
            const norm = Math.sqrt(x * x + y * y);
            x = x / norm * 1.5;
            y = y / norm * 1.5;
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            
            // Draw vector
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + x * scale, centerY - y * scale);
            ctx.stroke();
            
            // Arrowhead
            const angle = Math.atan2(-y, x);
            const headLength = 10;
            
            ctx.beginPath();
            ctx.moveTo(centerX + x * scale, centerY - y * scale);
            ctx.lineTo(
                centerX + x * scale - headLength * Math.cos(angle - Math.PI/6),
                centerY - y * scale + headLength * Math.sin(angle - Math.PI/6)
            );
            ctx.lineTo(
                centerX + x * scale - headLength * Math.cos(angle + Math.PI/6),
                centerY - y * scale + headLength * Math.sin(angle + Math.PI/6)
            );
            ctx.closePath();
            ctx.fill();
        }
        
        function showEigenDecomposition() {
            // Show eigenvalue decomposition animation
            drawEigenspace();
            
            // Add text explanation
            const ctx = eigenCtx;
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText('γ = V Λ V^T where:', 50, 450);
            ctx.fillText('V = eigenvectors, Λ = diag(0, 1, 1, ...)', 50, 470);
        }
        
        function animateEigenTransform() {
            let t = 0;
            const duration = 3000;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                t = Math.min(elapsed / duration, 1);
                
                drawEigenspace();
                
                // Show transformation effect
                const testVectors = [
                    {x: 1.5, y: 1.5},  // Along 1
                    {x: 1.5, y: -1.5}, // In 1⊥
                    {x: -1, y: 1.5}    // In 1⊥
                ];
                
                const ctx = eigenCtx;
                const centerX = 400;
                const centerY = 250;
                const scale = 100;
                
                testVectors.forEach(v => {
                    // Calculate projection
                    const mean = (v.x + v.y) / 2;
                    const projX = v.x - mean * t;
                    const projY = v.y - mean * t;
                    
                    ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX + v.x * scale, centerY - v.y * scale);
                    ctx.lineTo(centerX + projX * scale, centerY - projY * scale);
                    ctx.stroke();
                    
                    // Draw points
                    ctx.fillStyle = '#666';
                    ctx.beginPath();
                    ctx.arc(centerX + v.x * scale, centerY - v.y * scale, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.fillStyle = '#9C27B0';
                    ctx.beginPath();
                    ctx.arc(centerX + projX * scale, centerY - projY * scale, 4, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                if (t < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        function showSpectrum() {
            const ctx = eigenCtx;
            const width = 800;
            const height = 500;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw spectrum bar
            const barWidth = 600;
            const barHeight = 100;
            const barX = 100;
            const barY = 200;
            
            // Background
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            // Eigenvalues
            ctx.fillStyle = '#F44336';
            ctx.fillRect(barX, barY, 100, barHeight);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('λ₁ = 0', barX + 30, barY + 50);
            
            ctx.fillStyle = '#2196F3';
            ctx.fillRect(barX + 100, barY, 500, barHeight);
            ctx.fillStyle = 'white';
            ctx.fillText('λ₂, λ₃, ... = 1', barX + 300, barY + 50);
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = '20px Arial';
            ctx.fillText('Eigenvalue Spectrum of γ', 280, 150);
            
            ctx.font = '14px Arial';
            ctx.fillText('Dimension 1: Kernel (span of 1)', barX, barY + 130);
            ctx.fillText('Dimension N-1: Image (1⊥)', barX + 400, barY + 130);
        }
        
        // PCA Implementation
        let pcaCtx, pcaData = [];
        
        function initPCAVisualization() {
            const canvas = document.getElementById('pcaCanvas');
            pcaCtx = canvas.getContext('2d');
            generatePCAData();
        }
        
        function generatePCAData() {
            pcaData = [];
            const angle = Math.PI / 6; // 30 degrees
            
            for (let i = 0; i < 100; i++) {
                const t = (Math.random() - 0.5) * 6;
                const noise = (Math.random() - 0.5) * 0.8;
                
                pcaData.push({
                    x: t * Math.cos(angle) + noise * Math.sin(angle) + 2,
                    y: t * Math.sin(angle) - noise * Math.cos(angle) + 1
                });
            }
            
            drawPCAData();
        }
        
        function drawPCAData() {
            const ctx = pcaCtx;
            const width = 800;
            const height = 500;
            const centerX = width / 2;
            const centerY = height / 2;
            const scale = 60;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
            
            // Draw data points
            ctx.fillStyle = '#2196F3';
            pcaData.forEach(p => {
                ctx.beginPath();
                ctx.arc(centerX + p.x * scale, centerY - p.y * scale, 2, 0, 2 * Math.PI);
                ctx.fill();
            });
        }
        
        function showPCAWithout() {
            drawPCAData();
            
            // Calculate and draw principal components without centering
            const ctx = pcaCtx;
            const centerX = 400;
            const centerY = 250;
            const scale = 60;
            
            // Simplified PCA (just for visualization)
            // PC1 will point towards the data cloud (wrong!)
            ctx.strokeStyle = '#F44336';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + 200, centerY - 100);
            ctx.stroke();
            
            ctx.fillStyle = '#F44336';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('Wrong PC1', centerX + 210, centerY - 100);
            
            // Update stats
            document.getElementById('pc1Var').textContent = '45%';
            document.getElementById('pc2Var').textContent = '55%';
        }
        
        function showPCAWith() {
            // Center the data first
            const meanX = pcaData.reduce((sum, p) => sum + p.x, 0) / pcaData.length;
            const meanY = pcaData.reduce((sum, p) => sum + p.y, 0) / pcaData.length;
            
            const centeredData = pcaData.map(p => ({
                x: p.x - meanX,
                y: p.y - meanY
            }));
            
            // Draw centered data
            const ctx = pcaCtx;
            const width = 800;
            const height = 500;
            const centerX = width / 2;
            const centerY = height / 2;
            const scale = 60;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, height);
            ctx.stroke();
            
            // Draw centered data
            ctx.fillStyle = '#9C27B0';
            centeredData.forEach(p => {
                ctx.beginPath();
                ctx.arc(centerX + p.x * scale, centerY - p.y * scale, 2, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Draw correct principal components
            const angle = Math.PI / 6;
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 3;
            
            // PC1
            ctx.beginPath();
            ctx.moveTo(centerX - 150 * Math.cos(angle), centerY + 150 * Math.sin(angle));
            ctx.lineTo(centerX + 150 * Math.cos(angle), centerY - 150 * Math.sin(angle));
            ctx.stroke();
            
            ctx.fillStyle = '#4CAF50';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('Correct PC1', centerX + 160 * Math.cos(angle), centerY - 160 * Math.sin(angle));
            
            // PC2
            ctx.strokeStyle = '#FF9800';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - 80 * Math.sin(angle), centerY - 80 * Math.cos(angle));
            ctx.lineTo(centerX + 80 * Math.sin(angle), centerY + 80 * Math.cos(angle));
            ctx.stroke();
            
            ctx.fillStyle = '#FF9800';
            ctx.fillText('PC2', centerX + 90 * Math.sin(angle), centerY + 90 * Math.cos(angle));
            
            // Update stats
            document.getElementById('pc1Var').textContent = '85%';
            document.getElementById('pc2Var').textContent = '15%';
        }
        
        function comparePCA() {
            // Split screen comparison
            const ctx = pcaCtx;
            const width = 800;
            const height = 500;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw dividing line
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(width / 2, 0);
            ctx.lineTo(width / 2, height);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Without Centering', width / 4 - 60, 30);
            ctx.fillText('With Centering', 3 * width / 4 - 50, 30);
            
            const scale = 30;
            const leftCenterX = width / 4;
            const rightCenterX = 3 * width / 4;
            const centerY = height / 2;
            
            // Draw axes for both
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            // Left axes
            ctx.beginPath();
            ctx.moveTo(50, centerY);
            ctx.lineTo(width / 2 - 50, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(leftCenterX, 50);
            ctx.lineTo(leftCenterX, height - 50);
            ctx.stroke();
            
            // Right axes
            ctx.beginPath();
            ctx.moveTo(width / 2 + 50, centerY);
            ctx.lineTo(width - 50, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(rightCenterX, 50);
            ctx.lineTo(rightCenterX, height - 50);
            ctx.stroke();
            
            // Draw data on left (uncentered)
            ctx.fillStyle = '#2196F3';
            pcaData.forEach(p => {
                ctx.beginPath();
                ctx.arc(leftCenterX + p.x * scale, centerY - p.y * scale, 2, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Wrong PC on left
            ctx.strokeStyle = '#F44336';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(leftCenterX, centerY);
            ctx.lineTo(leftCenterX + 100, centerY - 50);
            ctx.stroke();
            
            // Draw centered data on right
            const meanX = pcaData.reduce((sum, p) => sum + p.x, 0) / pcaData.length;
            const meanY = pcaData.reduce((sum, p) => sum + p.y, 0) / pcaData.length;
            
            ctx.fillStyle = '#9C27B0';
            pcaData.forEach(p => {
                ctx.beginPath();
                ctx.arc(rightCenterX + (p.x - meanX) * scale, centerY - (p.y - meanY) * scale, 2, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Correct PC on right
            const angle = Math.PI / 6;
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(rightCenterX - 75 * Math.cos(angle), centerY + 75 * Math.sin(angle));
            ctx.lineTo(rightCenterX + 75 * Math.cos(angle), centerY - 75 * Math.sin(angle));
            ctx.stroke();
        }
        
        // Initialize first tab on load
        window.onload = () => {
            initMatrixVisualization();
        };
    </script>
</body>
</html>
